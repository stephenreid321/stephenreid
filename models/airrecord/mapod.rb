class Mapod < Airrecord::Table
  self.base_key = ENV['AIRTABLE_BASE_KEY']
  self.table_name = 'Mapods'

  def self.prompt
    %(Write a comprehensive, markdown-formatted summary of this podcast for a well-educated audience.

* Don't simply mention the topics discussed; explain the speaker's views and opinions in detail.
* Start with a # first level header, and then use ## second level headers for each topic covered.
* Divide the summary into at least 5 topics.
* Write at least 2 paragraphs for each topic.
* Write at least 70 words per paragraph.
* Include quotes of things the speaker actually said, including a key pull-out quote for each topic that perfectly fits the topic.
* Put pull-out quotes midway through topic sections, not at the beginning or end of sections.
* Pull-out quotes should be at least 2 sentences long.
* Don't repeat a quote as a pull-out if it's already featured in the summary.
* Don't start a pull-out quote with 'And', 'But', or 'It's like'.
* Don't attribute pull-out quotes.)
  end

  def wizper
    post = self

    puts 'downloading'
    audio_path = `python tasks/youtube_audio.py "#{post['Link']}"`.strip

    puts 'uploading'
    new_audio_path = "#{post['Title'].parameterize}.mp4"
    File.rename(audio_path, new_audio_path)
    audio_upload = Upload.create(file: File.open(new_audio_path))

    puts 'getting transcript'
    r = `python tasks/wizper.py "#{audio_upload.file.url}"`
    audio_upload.destroy

    puts 'saving txt'
    txt = JSON.parse(r)['text']
    txt_path = "#{post['Title'].parameterize}.txt"
    File.write(txt_path, txt)
    txt_upload = Upload.create(file: File.open(txt_path))
    post['Wizper txt'] = [{ url: txt_upload.file.url }]

    post.save
    txt_upload.destroy
    txt
  end

  def generate_essay
    post = self
    wizper unless post['Wizper txt']

    post['Generating essay'] = true
    post.save

    prompt = "#{Mapod.prompt}\n\n#{URI.open(post['Wizper txt'][0]['url']).read}"

    begin
      post['Generated by AI'] = 'Gemini 1.5 Pro'
      response = GEMINI_PRO.generate_content(
        {
          contents: { role: 'user', parts: { text: prompt } },
          generationConfig: { maxOutputTokens: 8192 }
        }
      )
      content = response.dig('candidates', 0, 'content', 'parts', 0, 'text')
    rescue StandardError
      content = nil
    end

    puts "#{content}\n\n"
    post['Essay'] = content
    post['Generating essay'] = false
    post.save
  end

  def speaker_name
    post = self
    name = post['Title'].split(' with ').last.split('(').first
    name = name.split(' - ').last if name.include?(' - ')
    puts "#{post['Title']} => #{name}" if name.split(' ').length <= 3
    name
  end

  def correct(a, b)
    post = self
    post['Essay'] = post['Essay'].gsub(a, b)
    post.save
  end
end
