<div class="mb-3">
  <div class="form-row">
    <div class="form-group col-md-2 mb-2">
      <label for="index-selector">Y-axis</label>
      <%= select_tag :index, options: @index_attributes.map { |i| [i.titleize, i] }, selected: (params[:index] || 'terminal_bench_hard'), id: 'index-selector', class: 'form-control' %>
    </div>
    <div class="form-group col-md-2 mb-2">
      <label for="x-axis-selector">X-axis</label>
      <%= select_tag :x_axis, options: [['Cost', 'cost'], ['Speed', 'speed']], selected: (params[:x_axis] || 'cost'), id: 'x-axis-selector', class: 'form-control' %>
    </div>
    <div class="form-group col-md-2 mb-2">
      <label for="reasoning-filter">Reasoning</label>
      <%= select_tag :reasoning, options: [
        ['All', ''],
        ['Yes', 'reasoning'],
        ['No', 'non-reasoning']
      ], selected: params[:reasoning], id: 'reasoning-filter', class: 'form-control' %>
    </div>
    <div class="form-group col-md-2 mb-2">
      <label for="open-source-filter">Open source</label>
      <%= select_tag :open_source, options: [
        ['All', ''],
        ['Yes', 'yes'],
        ['No', 'no']
      ], selected: params[:open_source], id: 'open-source-filter', class: 'form-control' %>
    </div>
    <div class="form-group col-md-2 mb-2">
      <label for="release-filter">Released in last</label>
      <%= select_tag :release, options: [['All time', '']] + [1, 3, 6, 12, 24].map { |m| ["#{pluralize(m, 'month')}", m.to_s] }, selected: (params[:release] || '3'), id: 'release-filter', class: 'form-control' %>
    </div>
  </div>
  <div class="form-row">
    <div class="form-group col-md-12 mb-2">
      <div class="d-flex flex-wrap gap-3">
        <% @index_attributes.each do |attr| %>
          <div class="form-group mb-1 mr-1">
            <button type="button" class="btn btn-sm btn-outline-secondary toggle-score-field" data-attr="<%= attr %>">
              <%= attr.titleize %> &gt;=
            </button>
            <div id="score-field-<%= attr %>" style="display: none;">
              <div class="input-group input-group-sm">
                <div class="input-group-prepend">
                  <span class="btn btn-sm btn-outline-secondary" id="label-<%= attr %>" style="cursor: pointer;">
                    <%= attr.titleize %> &gt;=
                  </span>
                </div>
                <%= number_field_tag "min_score_#{attr}".to_sym, value: params["min_score_#{attr}".to_sym], id: "min-score-#{attr}", class: 'form-control form-control-sm', step: 0.1 %>
              </div>
            </div>
          </div>
        <% end %>
      </div>
    </div>
  </div>
</div>

<div class="mb-4">
  <div class="card">
    <div class="card-header d-flex justify-content-between align-items-center">
      <h5 class="mb-0" id="chart-title"></h5>
      <button id="reset-zoom" class="btn btn-sm btn-outline-secondary">Reset zoom</button>
    </div>
    <div class="card-body">
      <div class="row">
        <div class="col-12 col-lg-9">
          <div style="position: relative; height: 400px;">
            <canvas id="cost-intelligence-chart"></canvas>
          </div>
        </div>
        <div class="col-12 col-lg-3 mt-3 mt-lg-0">
          <div id="pareto-list" class="mt-2">Loading...</div>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="table-responsive">
  <table id="models-table" class="table">
    <thead>
      <tr>
        <th>Model</th>
        <th>Creator</th>
        <th>Release</th>
        <th>Reasoning</th>
        <th>Open source</th>
        <% @index_attributes.each do |attr| %>
          <th><%= attr.titleize %></th>
        <% end %>
        <th>Speed</th>
        <th>Cost to Run</th>
      </tr>
    </thead>
    <tbody>
      <% @models.each do |model| %>
        <tr data-slug="<%= model['slug'] %>">
          <td>
            <strong><a href="https://artificialanalysis.ai/models/<%= model['slug'] %>" target="_blank" class="text-dark"><%= model['name'].gsub(/\s*\(Reasoning\)\s*/i, '').gsub(/\s*\(Non-reasoning\)\s*/i, '').strip %></a><% if model['reasoning_model'] %> ▲<% end %></strong>
            <br>
            <small class="text-muted"><code><%= model['slug'] %></code></small>
          </td>
          <td>
            <%= model.dig('model_creators', 'name') || 'N/A' %>
          </td>
          <td data-order="<%= model['release_date'] || '0000-00-00' %>"><%= display_or_dash(model['release_date']) { |d| Date.parse(d).strftime('%b %Y') rescue d } %></td>
          <td><%= bool_badge(model['reasoning_model'], yes_text: 'Reasoning', no_text: 'Non-reasoning') %></td>
          <td><%= bool_badge(model['is_open_weights']) %></td>
          <% @index_attributes.each do |attr| %>
            <% 
              score_key = "#{attr}_index"
              score = model[score_key]
              data_order = attr == 'omniscience' ? (model[score_key] || -999) : (model[score_key] || 0)
              cell_class = "#{attr}-index-cell"
            %>
            <td data-order="<%= data_order %>" class="<%= cell_class %>">
              <% if score %>
                <%= sprintf('%.1f', score) %>
                <small class="text-muted rank-display"></small>
              <% else %>
                <span class="text-muted">—</span>
              <% end %>
            </td>
          <% end %>
          <td data-order="<%= model['speed'] || 0 %>"><%= display_or_dash(model['speed'], format: '%.0f', suffix: 'tok/s') %></td>
          <td data-order="<%= model['cost_to_run'] || 0 %>"><%= display_or_dash(model['cost_to_run'], format: '%.0f', prefix: '$') %></td>
        </tr>
      <% end %>
    </tbody>
  </table>
</div>

<script>
  var INDEX_ATTRIBUTES = <%== @index_attributes.to_json %>;

  var modelsData = <%== @models.map { |m|
    result = {
      slug: m['slug'],
      name: m['name'],
      speed: (m['speed'] || 0).to_f,
      costToRun: (m['cost_to_run'] || 0).to_f,
      reasoningModel: !!m['reasoning_model'],
      isOpenWeights: !!m['is_open_weights'],
      releaseDate: m['release_date']
    }
    @index_attributes.each do |attr|
      score_key = "#{attr}_index"
      js_prop = "#{attr.camelize(:lower)}Index"
      # Preserve null for omniscience, default to 0 for others
      result[js_prop.to_sym] = attr == 'omniscience' ? m[score_key]&.to_f : (m[score_key] || 0).to_f
    end
    result
  }.to_json %>;

  var indexLabels = <%==
    @index_attributes.map { |attr| [attr, attr.titleize] }.to_h.to_json
  %>;

  // Clean model names for display (remove reasoning/non-reasoning suffixes)
  function cleanModelName(name) {
    return name.replace(/\s*\(Reasoning\)\s*/gi, '').replace(/\s*\(Non-reasoning\)\s*/gi, '').trim();
  }

  $(function() {
    var table = $('#models-table').DataTable({
      paging: false,
      searching: true,
      info: false,
      order: [[2, 'desc']], // Sort by Release date descending
      columnDefs: [
        { type: 'num', targets: [5, 6, 7, 8, 9, 10, 11, 12, 13] } // Numeric columns (index attributes + speed + cost)
      ]
    });

    // Show fields that already have values on page load
    <% @index_attributes.each do |attr| %>
      <% if params["min_score_#{attr}".to_sym].present? %>
        $('#score-field-<%= attr %>').show();
        $('button[data-attr="<%= attr %>"]').hide();
      <% end %>
    <% end %>

    // Toggle score field visibility on button click
    $('.toggle-score-field').on('click', function() {
      var attr = $(this).data('attr');
      var $button = $(this);
      var $field = $('#score-field-' + attr);

      // Hide any other empty fields first
      $('[id^="score-field-"]').each(function() {
        var $otherField = $(this);
        var otherAttr = $otherField.attr('id').replace('score-field-', '');
        if (otherAttr !== attr) {
          var $otherInput = $('#min-score-' + otherAttr);
          var value = $otherInput.val();
          if (!value || value.trim() === '') {
            $otherField.hide();
            $('button[data-attr="' + otherAttr + '"]').show();
          }
        }
      });

      $button.hide();
      $field.show();
      $('#min-score-' + attr).focus();
      updateLabelStyle(attr);
    });

    // Function to update label styling based on input value
    function updateLabelStyle(attr) {
      var $input = $('#min-score-' + attr);
      var $label = $('#label-' + attr);
      var value = $input.val();

      if (value && value.trim() !== '') {
        $label.removeClass('btn-outline-secondary').addClass('btn-primary');
      } else {
        $label.removeClass('btn-primary').addClass('btn-outline-secondary');
      }
    }

    // Update label styles on input change
    $('[id^="min-score-"]').on('input change', function() {
      var attr = $(this).attr('id').replace('min-score-', '');
      updateLabelStyle(attr);
    });

    // Update label styles for fields with initial values on page load
    <% @index_attributes.each do |attr| %>
      <% if params["min_score_#{attr}".to_sym].present? %>
        updateLabelStyle('<%= attr %>');
      <% end %>
    <% end %>

    // Handle label click to reset field to blank and hide
    $('[id^="label-"]').on('click', function() {
      var attr = $(this).attr('id').replace('label-', '');
      var $input = $('#min-score-' + attr);
      var $field = $('#score-field-' + attr);
      var $toggleButton = $('button[data-attr="' + attr + '"]');

      // Set field to blank
      $input.val('');

      // Hide the field container
      $field.hide();

      // Show the toggle button
      $toggleButton.show();

      // Update label style
      updateLabelStyle(attr);

      // Trigger change event to update filters
      $input.trigger('change');
    });

    // Calculate and update ranks based on visible (filtered) rows
    function updateRanks() {
      var visibleRows = table.rows({ search: 'applied' }).nodes();
      var indexColumns = INDEX_ATTRIBUTES.map(function(attr, idx) {
        return {
          name: attr + '_index',
          cellClass: attr + '-index-cell',
          colIndex: idx + 5
        };
      });

      indexColumns.forEach(function(indexCol) {
        // First, clear all rank displays for this column
        $('td.' + indexCol.cellClass + ' .rank-display').text('');

        // Collect scores from visible rows
        var scores = [];
        $(visibleRows).each(function() {
          var row = $(this);
          var cell = row.find('td.' + indexCol.cellClass);
          var score = parseFloat(cell.data('order')) || 0;

          if (score > 0) {
            scores.push({ score: score, cell: cell });
          }
        });

        // Sort by score descending
        scores.sort(function(a, b) { return b.score - a.score; });

        // Calculate ranks (handle ties)
        var currentRank = 1;
        scores.forEach(function(item, idx) {
          if (idx > 0 && scores[idx - 1].score !== item.score) {
            currentRank = idx + 1;
          }

          var rankDisplay = item.cell.find('.rank-display');
          rankDisplay.text('(' + currentRank + '/' + scores.length + ')');
        });
      });
    }

    // Store label positions for click detection
    var labelPositions = [];

    // Custom plugin for leader lines with collision avoidance
    var leaderLinePlugin = {
      id: 'leaderLines',
      afterDatasetsDraw: function(chart) {
        var ctx = chart.ctx;
        var labels = [];
        var allPoints = []; // All Pareto point positions
        var labelHeight = 12;
        var labelPadding = 4;
        var baseLineLength = 25;
        var pointRadius = 12; // Approximate point radius for collision

        // Clear previous label positions
        labelPositions = [];

        // First pass: collect all Pareto points
        chart.data.datasets.forEach(function(dataset, datasetIndex) {
          if (dataset.type === 'line') return;
          var meta = chart.getDatasetMeta(datasetIndex);
          meta.data.forEach(function(element, index) {
            var dataPoint = dataset.data[index];
            if (!dataPoint.isPareto) return;

            ctx.font = '10px sans-serif';
            var displayLabel = cleanModelName(dataPoint.label);
            var lightbulbSymbol = dataPoint.reasoningModel ? ' ▲' : '';
            var labelWithIcon = displayLabel + lightbulbSymbol;
            var textWidth = ctx.measureText(labelWithIcon).width;

            var pointInfo = {
              label: labelWithIcon,
              pointX: element.x,
              pointY: element.y,
              textWidth: textWidth,
              angle: 0,
              lineLength: baseLineLength,
              slug: dataPoint.slug
            };
            labels.push(pointInfo);
            allPoints.push({ x: element.x, y: element.y });
          });
        });

        // Sort by x position (right to left, highest cost first)
        labels.sort(function(a, b) { return b.pointX - a.pointX; });

        // Calculate label end positions
        function calcLabelBox(lbl) {
          var endX = lbl.pointX + Math.cos(lbl.angle) * lbl.lineLength;
          var endY = lbl.pointY + Math.sin(lbl.angle) * lbl.lineLength;
          return {
            x: endX + labelPadding,
            y: endY - labelHeight / 2,
            width: lbl.textWidth,
            height: labelHeight,
            endX: endX,
            endY: endY
          };
        }

        // Check if two boxes overlap
        function boxesOverlap(a, b) {
          return !(a.x + a.width < b.x || b.x + b.width < a.x ||
                   a.y + a.height < b.y || b.y + b.height < a.y);
        }

        // Check if a box overlaps with a circle (point)
        function boxOverlapsPoint(box, point) {
          // Find closest point on box to circle center
          var closestX = Math.max(box.x, Math.min(point.x, box.x + box.width));
          var closestY = Math.max(box.y, Math.min(point.y, box.y + box.height));
          var dx = point.x - closestX;
          var dy = point.y - closestY;
          return (dx * dx + dy * dy) < (pointRadius * pointRadius);
        }

        // Try to resolve collisions iteratively
        var angles = [0, Math.PI/6, Math.PI/4, Math.PI/3, Math.PI/2.5, -Math.PI/8, -Math.PI/6];
        var lengths = [25, 35, 45, 55, 65, 75];

        for (var i = 0; i < labels.length; i++) {
          var currentLabel = labels[i];
          var bestConfig = { angle: 0, lineLength: baseLineLength, collisions: Infinity };

          // Try different angle/length combinations
          for (var ai = 0; ai < angles.length; ai++) {
            for (var li = 0; li < lengths.length; li++) {
              currentLabel.angle = angles[ai];
              currentLabel.lineLength = lengths[li];
              var currentBox = calcLabelBox(currentLabel);

              var collisionCount = 0;

              // Check against all previous labels
              for (var j = 0; j < i; j++) {
                var otherBox = calcLabelBox(labels[j]);
                if (boxesOverlap(currentBox, otherBox)) {
                  collisionCount++;
                }
              }

              // Check against all Pareto points
              for (var p = 0; p < allPoints.length; p++) {
                if (boxOverlapsPoint(currentBox, allPoints[p])) {
                  collisionCount++;
                }
              }

              // Prefer shorter lines and smaller angles when no collisions
              var score = collisionCount * 1000 + lengths[li] + Math.abs(angles[ai]) * 10;
              if (score < bestConfig.collisions * 1000 + bestConfig.lineLength + Math.abs(bestConfig.angle) * 10) {
                bestConfig = { angle: angles[ai], lineLength: lengths[li], collisions: collisionCount };
              }

              if (collisionCount === 0) break; // Found good config, stop searching lengths
            }
            if (bestConfig.collisions === 0) break; // Found good config, stop searching angles
          }

          currentLabel.angle = bestConfig.angle;
          currentLabel.lineLength = bestConfig.lineLength;
        }

        // Draw all labels with resolved positions
        labels.forEach(function(lbl) {
          var box = calcLabelBox(lbl);

          ctx.save();
          // Draw leader line
          ctx.beginPath();
          ctx.moveTo(lbl.pointX, lbl.pointY);
          ctx.lineTo(box.endX, box.endY);
          ctx.strokeStyle = '#999';
          ctx.lineWidth = 1;
          ctx.stroke();

          // Draw label
          ctx.font = '10px sans-serif';
          ctx.fillStyle = '#666';
          ctx.textBaseline = 'middle';
          ctx.textAlign = 'left';
          ctx.fillText(lbl.label, box.endX + labelPadding, box.endY);
          ctx.restore();

          // Store label position for click detection
          labelPositions.push({
            x: box.x,
            y: box.y,
            width: box.width,
            height: box.height,
            slug: lbl.slug
          });
        });
      }
    };

    // Initialize scatter chart
    var ctx = document.getElementById('cost-intelligence-chart').getContext('2d');
    Chart.register(ChartDataLabels);
    var chart = new Chart(ctx, {
      type: 'scatter',
      data: { datasets: [] },
      plugins: [leaderLinePlugin],
      options: {
        responsive: true,
        maintainAspectRatio: false,
        layout: {
          padding: { left: 20, right: 20, top: 10, bottom: 10 }
        },
        plugins: {
          datalabels: {
            display: false // Labels drawn by leaderLinePlugin
          },
          tooltip: {
            callbacks: {
              label: function(context) {
                var point = context.raw;
                var xAxisType = $('#x-axis-selector').val();
                var xLabel = xAxisType === 'speed' ? 'Speed ' + point.x.toFixed(0) + ' tok/s' : 'Cost $' + point.x.toFixed(0);
                return cleanModelName(point.label) + ': Score ' + point.y.toFixed(1) + ', ' + xLabel;
              }
            }
          },
          legend: {
            display: true,
            position: 'bottom',
            labels: {
              usePointStyle: true,
              padding: 20,
              generateLabels: function(chart) {
                var original = Chart.defaults.plugins.legend.labels.generateLabels;
                var labels = original.call(this, chart);
                // Override colors to use solid colors from dataset metadata
                labels.forEach(function(label) {
                  var datasetIndex = label.datasetIndex;
                  var dataset = chart.data.datasets[datasetIndex];
                  if (dataset && dataset.legendColor) {
                    label.fillStyle = dataset.legendColor;
                    label.strokeStyle = dataset.legendColor;
                  }
                });
                return labels;
              }
            }
          },
          zoom: {
            pan: {
              enabled: true,
              mode: 'xy'
            },
            zoom: {
              wheel: { enabled: true },
              pinch: { enabled: true },
              mode: 'xy'
            }
          }
        },
        scales: {
          x: {
            type: 'logarithmic',
            title: { display: true, text: 'Cost to Run ($)', font: { weight: 'bold' } },
            grid: { color: 'rgba(0,0,0,0.05)' }
          },
          y: {
            title: { display: true, text: 'Intelligence', font: { weight: 'bold' } },
            grid: { color: 'rgba(0,0,0,0.05)' }
          }
        },
        onClick: function(evt, elements) {
          if (elements.length > 0) {
            var element = elements[0];
            var dataset = chart.data.datasets[element.datasetIndex];
            var dataPoint = dataset.data[element.index];
            if (dataPoint.slug) {
              window.open('https://artificialanalysis.ai/models/' + dataPoint.slug, '_blank');
            }
          }
        },
        onHover: function(evt, elements) {
          // Store hover state for data points
          chart._hoveringDataPoint = elements.length > 0;
        }
      }
    });

    // Initialize hover state
    chart._hoveringDataPoint = false;

    // Change cursor to pointer when hovering over labels or data points
    $('#cost-intelligence-chart').on('mousemove', function(evt) {
      var canvas = this;
      var rect = canvas.getBoundingClientRect();
      var scaleX = canvas.width / rect.width;
      var scaleY = canvas.height / rect.height;
      var x = (evt.clientX - rect.left) * scaleX;
      var y = (evt.clientY - rect.top) * scaleY;

      // Check if hovering over a label
      var overLabel = false;
      for (var i = 0; i < labelPositions.length; i++) {
        var label = labelPositions[i];
        if (x >= label.x && x <= label.x + label.width &&
            y >= label.y && y <= label.y + label.height) {
          overLabel = true;
          break;
        }
      }

      // Check if hovering over a data point (set by onHover callback)
      var overDataPoint = chart._hoveringDataPoint || false;

      canvas.style.cursor = (overLabel || overDataPoint) ? 'pointer' : 'default';
    });

    // Reset zoom button
    $('#reset-zoom').on('click', function() {
      chart.resetZoom();
    });

    // Make chart labels clickable
    $('#cost-intelligence-chart').on('click', function(evt) {
      var canvas = this;
      var rect = canvas.getBoundingClientRect();
      var scaleX = canvas.width / rect.width;
      var scaleY = canvas.height / rect.height;
      var x = (evt.clientX - rect.left) * scaleX;
      var y = (evt.clientY - rect.top) * scaleY;

      // Check if click is within any label bounds
      for (var i = 0; i < labelPositions.length; i++) {
        var label = labelPositions[i];
        if (x >= label.x && x <= label.x + label.width &&
            y >= label.y && y <= label.y + label.height) {
          window.open('https://artificialanalysis.ai/models/' + label.slug, '_blank');
          return;
        }
      }
    });


    // Convert snake_case to camelCase (e.g., terminal_bench_hard -> terminalBenchHard)
    function snakeToCamel(str) {
      return str.replace(/_([a-z])/g, function(match, letter) {
        return letter.toUpperCase();
      });
    }

    function getIndexValue(model, indexType) {
      return model[snakeToCamel(indexType) + 'Index'];
    }

    function getMinScores() {
      var scores = {};
      INDEX_ATTRIBUTES.forEach(function(attr) {
        if (attr === 'omniscience') {
          var val = $('#min-score-' + attr).val();
          scores[attr] = val === '' || val === null ? null : parseFloat(val);
        } else {
          scores[attr] = parseFloat($('#min-score-' + attr).val()) || 0;
        }
      });
      return scores;
    }

    function updateChart() {
      var selectedIndex = $('#index-selector').val();
      var xAxisType = $('#x-axis-selector').val();
      var reasoningFilter = $('#reasoning-filter').val();
      var openSourceFilter = $('#open-source-filter').val();
      var releaseFilter = $('#release-filter').val();
      var minScores = getMinScores();

      // Update title and axis labels
      var indexLabel = indexLabels[selectedIndex];
      var xAxisLabel = xAxisType === 'speed' ? 'Speed' : 'Cost to Run';
      var xAxisUnit = xAxisType === 'speed' ? ' (tok/s)' : ' ($)';
      $('#chart-title').text(indexLabel + ' vs ' + xAxisLabel);
      chart.options.scales.y.title.text = indexLabel;
      chart.options.scales.x.title.text = xAxisLabel + xAxisUnit;
      // Use linear scale for speed, logarithmic for cost
      chart.options.scales.x.type = xAxisType === 'speed' ? 'linear' : 'logarithmic';

      // Calculate cutoff date for release filter
      var cutoffDate = null;
      if (releaseFilter) {
        cutoffDate = new Date();
        cutoffDate.setMonth(cutoffDate.getMonth() - parseInt(releaseFilter));
      }

      // Filter models based on current filters
      var filteredModels = modelsData.filter(function(model) {
        var reasoningMatch = true;
        var openSourceMatch = true;
        var releaseMatch = true;

        if (reasoningFilter === 'reasoning') reasoningMatch = model.reasoningModel;
        else if (reasoningFilter === 'non-reasoning') reasoningMatch = !model.reasoningModel;

        if (openSourceFilter === 'yes') openSourceMatch = model.isOpenWeights;
        else if (openSourceFilter === 'no') openSourceMatch = !model.isOpenWeights;

        if (cutoffDate && model.releaseDate) {
          var modelDate = new Date(model.releaseDate);
          releaseMatch = modelDate >= cutoffDate;
        } else if (cutoffDate) {
          releaseMatch = false;
        }

        var indexValue = getIndexValue(model, selectedIndex);
        var xAxisValue = xAxisType === 'speed' ? model.speed : model.costToRun;

        // Check all min score filters
        var scoreMatch = true;
        var indexValueMap = {};
        INDEX_ATTRIBUTES.forEach(function(attr) {
          indexValueMap[attr] = model[snakeToCamel(attr) + 'Index'];
        });

        INDEX_ATTRIBUTES.forEach(function(attr) {
          if (attr === 'omniscience') {
            if (minScores[attr] != null && indexValueMap[attr] != null && indexValueMap[attr] < minScores[attr]) {
              scoreMatch = false;
            }
          } else {
            if (minScores[attr] > 0 && indexValueMap[attr] < minScores[attr]) {
              scoreMatch = false;
            }
          }
        });

        // For omniscience, allow negative values; for others, require > 0
        var indexValueValid = selectedIndex === 'omniscience'
          ? (indexValue != null && !isNaN(indexValue))
          : (indexValue > 0);

        return reasoningMatch && openSourceMatch && releaseMatch && scoreMatch && indexValueValid && xAxisValue > 0;
      });

      // Group by reasoning and open source
      // Colors: primary green for open source, grey for closed source
      // Shapes: triangle for reasoning (like a bright idea), circle for non-reasoning
      var openColor = '#4F9DFA';
      var closedColor = '#000000';

      var groups = {
        'Reasoning + Open Source': {
          filter: function(m) { return m.reasoningModel && m.isOpenWeights; },
          color: openColor,
          pointStyle: 'triangle'
        },
        'Reasoning + Closed': {
          filter: function(m) { return m.reasoningModel && !m.isOpenWeights; },
          color: closedColor,
          pointStyle: 'triangle'
        },
        'Non-reasoning + Open Source': {
          filter: function(m) { return !m.reasoningModel && m.isOpenWeights; },
          color: openColor,
          pointStyle: 'circle'
        },
        'Non-reasoning + Closed': {
          filter: function(m) { return !m.reasoningModel && !m.isOpenWeights; },
          color: closedColor,
          pointStyle: 'circle'
        }
      };

      // Calculate Pareto frontier FIRST so we can label only those points
      var allPoints = filteredModels.map(function(m) {
        var xValue = xAxisType === 'speed' ? m.speed : m.costToRun;
        return { x: xValue, y: getIndexValue(m, selectedIndex), label: m.name, reasoningModel: m.reasoningModel, slug: m.slug };
      });

      // Sort by x-axis value (ascending for cost, descending for speed)
      if (xAxisType === 'speed') {
        allPoints.sort(function(a, b) { return b.x - a.x; }); // Higher speed first
      } else {
        allPoints.sort(function(a, b) { return a.x - b.x; }); // Lower cost first
      }

      // Find Pareto-optimal points (with epsilon for near-ties)
      var paretoPoints = [];
      var paretoInfo = {}; // Store both membership and index
      var maxIntelligence = -Infinity;
      var epsilon = 1.0; // Include points within 1 intelligence point of the frontier

      for (var i = 0; i < allPoints.length; i++) {
        if (allPoints[i].y > maxIntelligence - epsilon) {
          paretoInfo[allPoints[i].label] = paretoPoints.length; // Store index
          paretoPoints.push(allPoints[i]);
          if (allPoints[i].y > maxIntelligence) {
            maxIntelligence = allPoints[i].y;
          }
        }
      }


      chart.data.datasets = [];

      Object.keys(groups).forEach(function(label) {
        var group = groups[label];
        var models = filteredModels.filter(group.filter);
        if (models.length > 0) {
          var dataPoints = models.map(function(m) {
            var pIdx = paretoInfo[m.name];
            var xValue = xAxisType === 'speed' ? m.speed : m.costToRun;
            return {
              x: xValue,
              y: getIndexValue(m, selectedIndex),
              label: m.name,
              slug: m.slug,
              isPareto: pIdx !== undefined,
              paretoIndex: pIdx || 0,
              reasoningModel: m.reasoningModel
            };
          });
          chart.data.datasets.push({
            label: label,
            data: dataPoints,
            backgroundColor: dataPoints.map(function(point) {
              return group.color + (point.isPareto ? 'ff' : '33');
            }),
            legendColor: group.color, // Solid color for legend
            borderWidth: 0,
            pointStyle: group.pointStyle,
            pointRadius: 10,
            pointHoverRadius: 12,
            datalabels: { display: false }
          });
        }
      });

      // Add Pareto frontier as a line
      if (paretoPoints.length > 1) {
        chart.data.datasets.unshift({
          label: 'Pareto Frontier',
          data: paretoPoints,
          type: 'line',
          borderColor: '#ff6b6b',
          borderWidth: 2,
          borderDash: [5, 5],
          fill: false,
          pointRadius: 0,
          pointStyle: 'line',
          tension: 0,
          datalabels: { display: false }
        });
      }

      // Update Pareto list (sorted by x-axis value, highest first)
      if (paretoPoints.length > 0) {
        var sortedPareto = paretoPoints.slice().sort(function(a, b) { return b.x - a.x; });
        var paretoHtml = '<ul class="list-unstyled mb-0">' + sortedPareto.map(function(p) {
          var lightbulbIcon = p.reasoningModel ? ' ▲' : '';
          var xDisplay = xAxisType === 'speed' ? p.x.toFixed(0) + ' tok/s' : '$' + p.x.toFixed(0);
          return '<li><strong><a href="https://artificialanalysis.ai/models/' + p.slug + '" target="_blank" class="text-dark">' + cleanModelName(p.label) + '</a>' + lightbulbIcon + '</strong> <span class="text-muted">(' + xDisplay + ' @ ' + p.y.toFixed(1) + ')</span></li>';
        }).join('') + '</ul>';
        $('#pareto-list').html(paretoHtml);
      } else {
        $('#pareto-list').html('<em>No models match current filters</em>');
      }

      chart.update();
    }

    // Custom filter function for table
    $.fn.dataTable.ext.search.push(
      function(settings, data, dataIndex) {
        var reasoningFilter = $('#reasoning-filter').val();
        var openSourceFilter = $('#open-source-filter').val();
        var releaseFilter = $('#release-filter').val();
        var selectedIndex = $('#index-selector').val();
        var minScores = getMinScores();

        if (settings.nTable.id !== 'models-table') return true;

        var row = table.row(dataIndex).node();
        var reasoningCell = $(row).find('td:eq(3)');
        var openSourceCell = $(row).find('td:eq(4)');

        var reasoningMatch = true;
        var openSourceMatch = true;
        var releaseMatch = true;
        var scoreMatch = true;

        if (reasoningFilter === 'reasoning') {
          reasoningMatch = reasoningCell.find('.badge-success').length > 0 && reasoningCell.text().includes('Reasoning');
        } else if (reasoningFilter === 'non-reasoning') {
          reasoningMatch = reasoningCell.find('.badge-secondary').length > 0 && reasoningCell.text().includes('Non-reasoning');
        }

        if (openSourceFilter === 'yes') {
          openSourceMatch = openSourceCell.find('.badge-success').length > 0 && openSourceCell.text().includes('Yes');
        } else if (openSourceFilter === 'no') {
          openSourceMatch = openSourceCell.find('.badge-secondary').length > 0 && openSourceCell.text().includes('No');
        }

        if (releaseFilter) {
          var cutoffDate = new Date();
          cutoffDate.setMonth(cutoffDate.getMonth() - parseInt(releaseFilter));
          var cellData = $(row).find('td:eq(2)').data('order') || '';
          if (cellData && cellData !== '0000-00-00') {
            var modelDate = new Date(cellData);
            releaseMatch = modelDate >= cutoffDate;
          } else {
            releaseMatch = false;
          }
        }

        // Check all min score filters
        var indexColIndices = {};
        INDEX_ATTRIBUTES.forEach(function(attr, idx) {
          indexColIndices[attr] = idx + 5;
        });

        INDEX_ATTRIBUTES.forEach(function(attr) {
          if (attr === 'omniscience') {
            if (minScores[attr] != null) {
              var score = parseFloat($(row).find('td:eq(' + indexColIndices[attr] + ')').data('order'));
              if (!isNaN(score) && score < minScores[attr]) scoreMatch = false;
            }
          } else {
            if (minScores[attr] > 0) {
              var score = parseFloat($(row).find('td:eq(' + indexColIndices[attr] + ')').data('order')) || 0;
              if (score < minScores[attr]) scoreMatch = false;
            }
          }
        });

        return reasoningMatch && openSourceMatch && releaseMatch && scoreMatch;
      }
    );

    // Apply filters when dropdowns change
    var minScoreSelectors = INDEX_ATTRIBUTES.map(function(attr) { return '#min-score-' + attr; }).join(', ');
    $('#index-selector, #reasoning-filter, #open-source-filter, #release-filter, #x-axis-selector, ' + minScoreSelectors).on('change input', function() {
      table.draw();
      updateRanks();
      updateChart();
    });

    // Update ranks when table is redrawn (for search/filter changes)
    table.on('draw', function() {
      updateRanks();
    });

    // Handle window resize for mobile responsiveness
    var resizeTimer;
    $(window).on('resize', function() {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(function() {
        chart.resize();
        updateChart();
      }, 250);
    });

    // Initial chart render and rank update
    updateRanks();
    updateChart();
  });
</script>
